<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eco Route Planner</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d0d0d; /* Even darker background inspired by image_a42e22.jpg */
            color: #e0e0e0; /* Light text for dark background */
        }
        /* Ensure the map container has a defined height */
        #map {
            height: 500px;
            width: 100%;
            border-radius: 0.75rem;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.6); /* Deeper shadow for dark theme */
            border: 1px solid #222; /* Subtle border */
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1a1a1a; /* Darker track */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #4CAF50; /* Green accent thumb */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #43A047;
        }
        /* Custom styles for mode cards to match the new aesthetic */
        .card-eco-green { background-color: #1a1a1a; border-color: #4CAF50; } /* Darker green for eco */
        .card-eco-blue { background-color: #1a1a1a; border-color: #4CAF50; } /* All cards primarily dark with green accent */
        .card-eco-purple { background-color: #1a1a1a; border-color: #4CAF50; }
        .card-eco-red { background-color: #1a1a1a; border-color: #4CAF50; }


        .ring-highlight {
            box-shadow: 0 0 0 4px #4CAF50, 0 0 0 6px #0d0d0d; /* Green highlight on dark background */
        }
        .comparison-bar {
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s ease-in-out;
        }
        .progress-bar {
            height: 8px;
            border-radius: 4px;
            transition: width 0.3s ease-in-out;
        }
        .route-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }
        .route-details.expanded {
            max-height: 500px; /* Adjust as needed to accommodate content */
        }
        /* Newsletter section styling */
        .newsletter-section {
            background: linear-gradient(135deg, #1a1a1a, #0d0d0d);
            border-radius: 1rem;
            padding: 2.5rem;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.6);
            text-align: center;
            color: #e0e0e0;
        }
        .newsletter-section input[type="email"] {
            background-color: #222;
            border: 1px solid #444;
            color: #e0e0e0;
        }
        .newsletter-section input[type="email"]::placeholder {
            color: #888;
        }
        .newsletter-section button {
            background-color: #4CAF50; /* Green accent */
            color: white;
            transition: background-color 0.3s ease;
        }
        .newsletter-section button:hover {
            background-color: #43A047;
        }
        /* Autocomplete dropdown styles */
        .autocomplete-dropdown {
            position: absolute;
            z-index: 1000;
            background-color: #2a2a2a;
            border: 1px solid #444;
            border-radius: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            width: calc(100% - 2rem); /* Match input width */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            margin-top: 0.25rem;
        }
        .autocomplete-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            color: #e0e0e0;
            border-bottom: 1px solid #333;
        }
        .autocomplete-item:hover {
            background-color: #3a3a3a;
        }
        .autocomplete-item:last-child {
            border-bottom: none;
        }
    </style>


    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <!-- React and ReactDOM CDNs -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX transformation in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-100">
    <div id="root"></div>


    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>


    <!-- Your React App Script -->
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;


        // Custom UI Components (using shadcn/ui like patterns)
        const Card = ({ className, children }) => (
          <div className={`rounded-xl border bg-[#1a1a1a] text-[#e0e0e0] shadow-md ${className}`}>
            {children}
          </div>
        );


        const CardHeader = ({ className, children }) => (
          <div className={`flex flex-col space-y-1.5 p-6 ${className}`}>
            {children}
          </div>
        );


        const CardTitle = ({ className, children }) => (
          <h3 className={`text-2xl font-semibold leading-none tracking-tight ${className}`}>
            {children}
          </h3>
        );


        const CardContent = ({ className, children }) => (
          <div className={`p-6 pt-0 ${className}`}>
            {children}
          </div>
        );


        const Button = ({ className, variant = 'default', size = 'default', disabled, children, ...props }) => {
          const baseClasses = "inline-flex items-center justify-center whitespace-nowrap rounded-lg text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50";
          const variantClasses = {
            default: "bg-[#4CAF50] text-white hover:bg-[#43A047] shadow-sm", /* Green accent */
            outline: "border border-[#444] bg-[#1a1a1a] text-[#e0e0e0] hover:bg-[#222] hover:text-white shadow-sm",
            ghost: "hover:bg-[#222] hover:text-white",
            destructive: "bg-[#F44336] text-white hover:bg-[#D32F2F] shadow-sm", /* Red accent for error/delete */
            eco: "bg-[#4CAF50] text-white hover:bg-[#43A047] shadow-md", /* Green accent for eco button */
          };
          const sizeClasses = {
            default: "h-10 px-4 py-2",
            sm: "h-9 rounded-md px-3",
            lg: "h-11 rounded-md px-8",
            icon: "h-10 w-10",
          };
          return (
            <button
              className={`${baseClasses} ${variantClasses[variant]} ${sizeClasses[size]} ${className}`}
              disabled={disabled}
              {...props}
            >
              {children}
            </button>
          );
        };


        const Input = ({ className, type = 'text', ...props }) => (
          <input
            type={type}
            className={`flex h-10 w-full rounded-lg border border-[#444] bg-[#222] px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-[#888] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[#4CAF50] focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 shadow-sm text-[#e0e0e0] ${className}`}
            {...props}
          />
        );


        const Label = ({ className, children, ...props }) => (
          <label className={`text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 text-[#e0e0e0] ${className}`} {...props}>
            {children}
          </label>
        );


        // --- API Keys ---
        // IMPORTANT: Using Geoapify API key for geocoding and routing
        const GEOAPIFY_API_KEY = '4c8596ef790b461d94dd7fbbfc1dcfda'; // Geoapify API Key


        // Open-Meteo doesn't use a traditional API key for its public forecast API,
        // but the variable name is kept for consistency.
        const OPENWEATHERMAP_API_KEY = '';


        // Fuel Price API Key
        const FUEL_PRICE_API_KEY = '2mGpGW2C1f5qz8hwbqxEHp:4kYBZamfRjJQYAYoS0zf6Q';




        // Helper function to convert Geoapify polyline format (array of [longitude, latitude])
        // to Leaflet's expected format (array of [latitude, longitude] arrays).
        function toLeafletLatLngs(geoapifyPoints) {
            // Geoapify points are [longitude, latitude], Leaflet expects [latitude, longitude]
            return geoapifyPoints.map(p => [p[1], p[0]]);
        }


        // Helper function to geocode an address string to LatLng using Geoapify Geocoding API
        const geocodeAddress = async (address) => {
            if (!GEOAPIFY_API_KEY) {
                throw new Error('Geoapify API Key is not set or is invalid for geocoding. Please update it in the code.');
            }
            const encodedAddress = encodeURIComponent(address);
            // Geoapify Geocoding API URL
            const geocodingUrl = `https://api.geoapify.com/v1/geocode/search?text=${encodedAddress}&apiKey=${GEOAPIFY_API_KEY}`;


            try {
                const response = await fetch(geocodingUrl);
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Geoapify Geocoding API Error:', errorData);
                    throw new Error(errorData.message || 'Failed to geocode address. Please check your API key and network connection.');
                }
                const data = await response.json();
                if (data.features && data.features.length > 0) {
                    // Geoapify returns [longitude, latitude]
                    return { lat: data.features[0].geometry.coordinates[1], lng: data.features[0].geometry.coordinates[0], address: data.features[0].properties.formatted };
                } else {
                    return null;
                }
            } catch (error) {
                console.error('Error in geocodeAddress:', error);
                throw error;
            }
        };

        // Helper function for reverse geocoding
        const reverseGeocode = async (lat, lng) => {
            if (!GEOAPIFY_API_KEY) {
                throw new Error('Geoapify API Key is not set or is invalid for reverse geocoding.');
            }
            const reverseGeocodingUrl = `https://api.geoapify.com/v1/geocode/reverse?lat=${lat}&lon=${lng}&apiKey=${GEOAPIFY_API_KEY}`;
            try {
                const response = await fetch(reverseGeocodingUrl);
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Geoapify Reverse Geocoding API Error:', errorData);
                    return `Lat: ${lat.toFixed(4)}, Lng: ${lng.toFixed(4)}`; // Fallback to coords
                }
                const data = await response.json();
                if (data.features && data.features.length > 0) {
                    return data.features[0].properties.formatted;
                } else {
                    return `Lat: ${lat.toFixed(4)}, Lng: ${lng.toFixed(4)}`; // Fallback to coords
                }
            } catch (error) {
                console.error('Error in reverseGeocode:', error);
                return `Lat: ${lat.toFixed(4)}, Lng: ${lng.toFixed(4)}`; // Fallback to coords
            }
        };


        // Fetch current gas prices using the provided API
        const fetchFuelPrices = async (lat, lng) => {
            if (!FUEL_PRICE_API_KEY) {
                console.warn('Fuel Price API Key is not set. Using default fuel price.');
                return { gasoline: 3.45, diesel: 3.89, electricity: 0.13 };
            }


            // Using CollectAPI endpoint based on the API key format
            const apiUrl = `https://api.collectapi.com/gasPrice/gasoline/fromCoordinates?lat=${lat}&lng=${lng}`;
            
            try {
                const response = await fetch(apiUrl, {
                    headers: {
                        'Authorization': `apikey ${FUEL_PRICE_API_KEY}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Fuel Price API Error:', errorData);
                    // Fallback to default prices on API error
                    return { gasoline: 3.45, diesel: 3.89, electricity: 0.13 };
                }
                
                const data = await response.json();
                if (data.success && data.result && data.result.gasoline) {
                    return {
                        gasoline: parseFloat(data.result.gasoline.price) || 3.45,
                        diesel: parseFloat(data.result.diesel.price) || 3.89, // Assuming diesel is also available or default
                        electricity: 0.13 // Electricity price is harder to get via this API, keep default
                    };
                } else {
                    console.warn('Fuel Price API did not return expected data. Using default prices.');
                    return { gasoline: 3.45, diesel: 3.89, electricity: 0.13 };
                }
            } catch (error) {
                console.error('Error fetching fuel prices:', error);
                return { gasoline: 3.45, diesel: 3.89, electricity: 0.13 };
            }
        };


        // Fetch weather data using Open-Meteo API
        const fetchWeatherData = async (lat, lng) => {
            // Open-Meteo public API does not require an API key
            const apiUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&hourly=temperature_2m&current_weather=true`;
            
            try {
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    console.error('Open-Meteo API Error:', response.status, response.statusText);
                    // Fallback to a generic weather object on error
                    return {
                        main: { temp: 'N/A' },
                        weather: [{ main: 'Unknown', description: 'weather data unavailable' }],
                        wind: { speed: 'N/A' }
                    };
                }
                
                const data = await response.json();
                if (data.current_weather) {
                    // Infer a simple description based on temperature or just use a generic one
                    let description = 'unknown conditions';
                    if (data.current_weather.temperature > 25) description = 'warm';
                    else if (data.current_weather.temperature > 15) description = 'mild';
                    else if (data.current_weather.temperature > 0) description = 'cool';
                    else description = 'cold';


                    return {
                        main: { temp: data.current_weather.temperature },
                        weather: [{ main: 'Current', description: description }],
                        wind: { speed: data.current_weather.windspeed }
                    };
                } else {
                    console.warn('Open-Meteo did not return current weather data. Using generic weather.');
                    return {
                        main: { temp: 'N/A' },
                        weather: [{ main: 'Unknown', description: 'weather data unavailable' }],
                        wind: { speed: 'N/A' }
                    };
                }
            } catch (error) {
                console.error('Error fetching weather data:', error);
                return {
                    main: { temp: 'N/A' },
                    weather: [{ main: 'Unknown', description: 'weather data unavailable' }],
                    wind: { speed: 'N/A' }
                };
            }
        };


        // Route Comparison Chart Component
        // Displays a visual comparison of different route modes based on time, cost, and CO2 emissions.
        const RouteComparisonChart = ({ results }) => {
            // Filter out Infinity values for proper max calculation, then find the max for scaling bars
            const maxTime = Math.max(...results.filter(r => r.time !== Infinity).map(r => r.time), 1); // Ensure not zero
            const maxCost = Math.max(...results.filter(r => r.cost !== Infinity).map(r => r.cost), 1);
            const maxCo2 = Math.max(...results.map(r => r.co2), 0.1); // Ensure not zero


            return (
              <div className='bg-[#1a1a1a] p-6 rounded-xl shadow-md border border-[#222]'>
                  <h3 className='text-xl font-bold text-[#e0e0e0] mb-6'>Route Comparison</h3>
                  <div className='space-y-6'>
                      {results.map(result => (
                          <div key={result.mode + (result.vehicleType || '')}>
                              <div className='flex items-center justify-between mb-2'>
                                  <span className='font-medium capitalize text-[#c0c0e0]'>
                                      {result.mode === 'driving' ? `${result.vehicleType || 'Driving'} ${result.mode}` : result.mode}
                                  </span>
                                  <span className='text-sm text-[#a0a0c0]'>
                                      {result.time === Infinity ? 'N/A' : `${result.time}min, $${result.cost.toFixed(2)}, ${result.co2.toFixed(2)}kg CO‚ÇÇ`}
                                  </span>
                              </div>
                              <div className='grid grid-cols-3 gap-2'>
                                  {/* Time bar (Green for eco-focus) */}
                                  <div className='bg-[#222] rounded-full h-3'>
                                      <div
                                          className='comparison-bar bg-[#4CAF50]' /* Green accent */
                                          style={{ width: result.time === Infinity ? '0%' : `${(result.time / maxTime) * 100}%` }}
                                      ></div>
                                  </div>
                                  {/* Cost bar (Green for eco-focus) */}
                                  <div className='bg-[#222] rounded-full h-3'>
                                      <div
                                          className='comparison-bar bg-[#4CAF50]' /* Green accent */
                                          style={{ width: result.cost === Infinity ? '0%' : `${(result.cost / maxCost) * 100}%` }}
                                      ></div>
                                  </div>
                                  {/* CO2 bar (Green for eco-focus) */}
                                  <div className='bg-[#222] rounded-full h-3'>
                                      <div
                                          className='comparison-bar bg-[#4CAF50]' /* Green accent */
                                          style={{ width: `${(result.co2 / maxCo2) * 100}%` }}
                                      ></div>
                                  </div>
                              </div>
                          </div>
                      ))}
                  </div>
                  <div className='flex justify-between text-xs text-[#a0a0c0] mt-4'>
                      <span>üïí Time</span>
                      <span>üí∞ Cost</span>
                      <span>üåç CO‚ÇÇ</span>
                  </div>
              </div>
            );
        };


        // Carbon Savings Calculator Component
        // Calculates and displays potential CO2 savings by choosing an eco-friendly option over driving.
        const CarbonSavingsCalculator = ({ results }) => {
            const drivingResult = results.find(r => r.mode === 'driving');
            // Filter out options that are not possible (time === Infinity)
            const ecoOptions = results.filter(r => r.mode !== 'driving' && r.time !== Infinity);
            
            if (!drivingResult || ecoOptions.length === 0) return null;


            // Find the eco-friendly option with the lowest CO2 emissions
            const bestEcoOption = ecoOptions.reduce((prev, current) => 
                prev.co2 < current.co2 ? prev : current
            );


            const savings = drivingResult.co2 - bestEcoOption.co2;
            // 1 tree absorbs approximately 21 kg of CO2 per year.
            const treesEquivalent = Math.round(savings / 0.021); 


            return (
              <div className='bg-[#1a1a1a] p-6 rounded-xl border border-[#4CAF50] shadow-md'>
                  <h3 className='text-xl font-bold text-[#4CAF50] mb-4'>Carbon Savings Calculator</h3>
                  <div className='space-y-4'>
                      <p className='text-[#c0c0e0]'>
                          By choosing {' '}
                          <span className='font-bold text-[#4CAF50] capitalize'>{bestEcoOption.mode}</span>
                          {' '} over driving, you'll save {' '}
                          <span className='font-bold text-[#4CAF50]'>{`${savings.toFixed(2)} kg of CO‚ÇÇ`}</span>
                      </p>
                      <div className='bg-[#222] p-4 rounded-lg'>
                          <div className='flex justify-between mb-2'>
                              <span className='text-sm font-medium text-[#c0c0e0]'>Carbon Reduction</span>
                              <span className='text-sm text-[#a0a0c0]'>{`${((savings / drivingResult.co2) * 100).toFixed(1)}%`}</span>
                          </div>
                          <div className='bg-[#333] rounded-full h-4'>
                              <div
                                  className='progress-bar bg-[#4CAF50]'
                                  style={{ width: `${Math.min((savings / drivingResult.co2) * 100, 100)}%` }}
                              ></div>
                          </div>
                      </div>
                  </div>
                  {treesEquivalent > 0 && (
                      <div className='bg-[#222] p-3 rounded-lg flex items-center mt-4'>
                          <span className='text-2xl mr-3'>üå≥</span>
                          <span className='text-[#c0c0e0]'>
                              This is equivalent to planting {treesEquivalent} tree{treesEquivalent !== 1 ? 's' : ''}!
                          </span>
                      </div>
                  )}
                  <a
                      href='https://www.carbonfund.org/'
                      target='_blank'
                      rel='noopener noreferrer'
                      className='inline-block bg-[#4CAF50] text-white px-4 py-2 rounded-lg hover:bg-[#43A047] transition-colors mt-4'
                  >
                      üå± Offset This Trip
                  </a>
              </div>
            );
        };


        // Route Details Panel Component
        // Displays detailed information about a selected route, including real directions
        // and weather impact. Elevation profile is removed as real data is not available.
        const RouteDetailsPanel = ({ route, isExpanded, onToggle, weather }) => {
            return (
              <div>
                  <Button
                      onClick={onToggle}
                      variant='ghost'
                      className='w-full mt-2 text-left text-[#4CAF50] hover:text-[#43A047]' /* Green accent for button */
                  >
                      {isExpanded ? '‚ñº Hide Details' : '‚ñ∂ Show Details'}
                  </Button>
                  <div className={`route-details ${isExpanded ? 'expanded' : ''}`}>
                      <div className='mt-4 space-y-4 p-4 bg-[#222] rounded-lg border border-[#333]'>
                          {/* Step-by-step directions */}
                          {route.instructions && route.instructions.length > 0 && (
                              <div>
                                  <h4 className='font-semibold mb-2 text-[#e0e0e0]'>Directions</h4>
                                  <ol className='list-decimal list-inside space-y-1 text-sm text-[#c0c0e0]'>
                                      {/* FIX: Directly render the string instruction */}
                                      {route.instructions.map((instruction, index) => (
                                          <li key={index}>{instruction}</li>
                                      ))}
                                  </ol>
                              </div>
                          )}
                          {/* Weather impact */}
                          {weather && (
                              <div>
                                  <h4 className='font-semibold mb-2 text-[#e0e0e0]'>Weather Impact</h4>
                                  <div className='bg-[#333] p-3 rounded border border-[#444]'>
                                      <p className='text-sm text-[#c0c0e0]'>
                                          {`Current: ${String(weather.weather[0].description)}, ${String(weather.main.temp)}¬∞C`}
                                      </p>
                                      {/* Specific warnings based on weather and mode (simplified due to Open-Meteo data) */}
                                      {route.mode === 'biking' && weather.main.temp < 5 && (
                                          <p className='text-[#FFC107] text-sm mt-1'>
                                              ‚ö†Ô∏è Cold weather might affect biking comfort.
                                          </p>
                                      )}
                                      {route.mode === 'walking' && weather.main.temp < 0 && (
                                          <p className='text-[#2196F3] text-sm mt-1'>
                                              ‚ùÑÔ∏è Dress warmly for cold weather.
                                          </p>
                                      )}
                                      {route.mode === 'biking' && weather.wind.speed > 10 && (
                                          <p className='text-[#F44336] text-sm mt-1'>
                                              üí® Strong winds might affect biking comfort.
                                          </p>
                                      )}
                                  </div>
                              </div>
                          )}
                      </div>
                  </div>
              </div>
            );
        };


        // Favorite Routes Component
        // Allows users to save and load frequently used routes using browser's localStorage.
        const FavoriteRoutes = ({ onLoadRoute, onSaveRoute }) => {
            const [favorites, setFavorites] = useState([]);
            const [saveMessage, setSaveMessage] = useState('');


            useEffect(() => {
                const saved = localStorage.getItem('ecoRouteFavorites'); // Use a unique key
                if (saved) {
                    setFavorites(JSON.parse(saved));
                }
            }, []);


            // Function to save a new favorite route
            const handleSaveFavorite = (startLocation, endLocation, waypoints) => {
                const newFavorite = {
                    id: Date.now(), // Unique ID
                    name: `${startLocation} ‚Üí ${endLocation}`,
                    startLocation,
                    endLocation,
                    waypoints,
                    savedAt: new Date().toISOString()
                };
                const updated = [...favorites, newFavorite];
                setFavorites(updated);
                localStorage.setItem('ecoRouteFavorites', JSON.stringify(updated));
                setSaveMessage('Route saved to favorites!');
                setTimeout(() => setSaveMessage(''), 3000); // Clear message after 3 seconds
            };


            // Function to delete a favorite route
            const deleteFavorite = (id) => {
                const updated = favorites.filter(f => f.id !== id);
                setFavorites(updated);
                localStorage.setItem('ecoRouteFavorites', JSON.stringify(updated));
            };


            // Expose save function to parent component
            useEffect(() => {
                onSaveRoute.current = handleSaveFavorite;
            }, [onSaveRoute, handleSaveFavorite]);


            return (
              <div className='space-y-4'>
                  <h3 className='text-lg font-semibold text-[#e0e0e0]'>Favorite Routes</h3>
                  {saveMessage && <div className='p-2 bg-[#4CAF50] text-white rounded text-sm text-center'>{saveMessage}</div>}
                  {favorites.length === 0 ? 
                      <p className='text-[#a0a0c0] text-sm'>No saved routes yet. Save your current route!</p> :
                      <div className='space-y-2 max-h-48 overflow-y-auto custom-scrollbar'>
                          {favorites.map(fav => (
                              <div key={fav.id} className='flex items-center justify-between bg-[#222] p-3 rounded border border-[#333] shadow-sm'>
                                  <div className='flex-1 mr-2'>
                                      <p className='font-medium text-sm text-[#c0c0e0] truncate'>{fav.name}</p>
                                      <p className='text-xs text-[#a0a0c0]'>
                                          {new Date(fav.savedAt).toLocaleDateString()}
                                      </p>
                                  </div>
                                  <div className='flex space-x-2'>
                                      <Button
                                          size='sm'
                                          variant='outline'
                                          onClick={() => onLoadRoute(fav)}
                                      >
                                          Load
                                      </Button>
                                      <Button
                                          size='sm'
                                          variant='destructive'
                                          onClick={() => deleteFavorite(fav.id)}
                                      >
                                          √ó
                                      </Button>
                                  </div>
                              </div>
                          ))}
                      </div>
                  }
              </div>
            );
        };


        // Time Optimization Component
        // Provides suggestions for optimal departure times based on traffic estimates.
        const TimeOptimization = ({ onTimeChange }) => {
            const [selectedTime, setSelectedTime] = useState('');
            const [suggestions, setSuggestions] = useState([]);


            const generateSuggestions = useCallback((time) => {
                // In a real scenario, this would involve calling a routing API with time-dependent traffic data.
                // Geoapify's Routing API does support 'departure_time' parameter for traffic.
                // For simplicity, we'll provide mock suggestions based on common traffic patterns.
                const mockSuggestions = [
                    { time: '07:30', benefit: 'Avoid morning rush, save ~12 min, reduce CO‚ÇÇ by ~8%' },
                    { time: '09:15', benefit: 'Light traffic, save ~8 min, reduce CO‚ÇÇ by ~5%' },
                    { time: '14:00', benefit: 'Off-peak hours, save ~15 min, reduce CO‚ÇÇ by ~12%' },
                    { time: '19:30', benefit: 'Evening light traffic, save ~6 min, reduce CO‚ÇÇ by ~4%' }
                ];
                setSuggestions(mockSuggestions);
            }, []);


            useEffect(() => {
                if (selectedTime) {
                    generateSuggestions(selectedTime);
                    onTimeChange(selectedTime);
                }
            }, [selectedTime, onTimeChange, generateSuggestions]);


            return (
              <div className='space-y-4 bg-[#1a1a1a] p-6 rounded-xl border border-[#4CAF50] shadow-md'>
                  <h3 className='text-xl font-bold text-[#4CAF50]'>Departure Time Optimization</h3>
                  <Label htmlFor="departureTime" className="text-base text-[#c0c0e0] mb-2 block">Preferred Departure Time</Label>
                  <Input
                      type='time'
                      id='departureTime'
                      value={selectedTime}
                      onChange={(e) => setSelectedTime(e.target.value)}
                      className='w-full p-2 border-[#333] rounded-lg'
                  />
                  {suggestions.length > 0 && (
                      <div className='bg-[#222] p-4 rounded-lg mt-4'>
                          <h4 className='font-medium mb-2 text-[#c0c0e0]'>Optimal departure times:</h4>
                          <div className='space-y-2'>
                              {suggestions.slice(0, 2).map((suggestion, index) => (
                                  <div key={index} className='text-sm bg-[#333] p-2 rounded border border-[#444] text-[#c0c0e0]'>
                                      <span className='font-medium text-[#4CAF50]'>{suggestion.time}</span>
                                      <span className='text-[#c0c0e0] ml-2'>{suggestion.benefit}</span>
                                  </div>
                              ))}
                          </div>
                      </div>
                  )}
              </div>
            );
        };


        // Multi-Modal Suggestions Component
        // This component now simply displays the individual route options clearly,
        // as complex multi-modal planning (e.g., "drive to station, then bus") requires specialized APIs.
        const MultiModalSuggestions = ({ results }) => {
            // Filter out driving mode as it's typically the "alternative" to eco-friendly multi-modal
            const ecoModes = results.filter(r => r.mode !== 'driving' && r.time !== Infinity);


            if (ecoModes.length === 0) return null;


            return (
              <div className='bg-[#1a1a1a] p-6 rounded-xl border border-[#4CAF50] shadow-md'>
                  <h3 className='text-xl font-bold text-[#4CAF50] mb-4'>
                      üöåüö¥ Eco-Friendly Route Options
                  </h3>
                  <div className='space-y-4'>
                      {ecoModes.map((option, index) => (
                          <div key={index} className='bg-[#222] p-4 rounded-lg border border-[#333]'>
                              <h4 className='font-semibold text-[#c0c0e0] capitalize'>{option.mode}</h4>
                              <div className='flex justify-between text-sm text-[#a0a0c0] mt-2'>
                                  <span>‚è±Ô∏è {option.time} min</span>
                                  <span>üí∞ ${option.cost.toFixed(2)}</span>
                                  <span>üå± {option.co2.toFixed(2)} kg CO‚ÇÇ</span>
                              </div>
                          </div>
                      ))}
                  </div>
              </div>
            );
        };


        // Main EcoRoutePlanner component
        function App() {
          const [startLocation, setStartLocation] = useState('');
          const [endLocation, setEndLocation] = useState('');
          const [waypoints, setWaypoints] = useState([]);
          const [startCoords, setStartCoords] = useState(null);
          const [endCoords, setEndCoords] = useState(null);
          const [waypointCoords, setWaypointCoords] = useState([]);
          const [distance, setDistance] = useState(null);
          const [drivingDuration, setDrivingDuration] = useState(null);
          const [results, setResults] = useState([]);
          const [isCalculating, setIsCalculating] = useState(false);
          const [error, setError] = useState(null);
          const [mapInitialized, setMapInitialized] = useState(false);
          const [evMode, setEvMode] = useState(false);
          const [selectedVehicleType, setSelectedVehicleType] = useState('gasoline');
          const [expandedRoute, setExpandedRoute] = useState(null);
          const [weather, setWeather] = useState(null);
          const [fuelPrices, setFuelPrices] = useState(null);
          const [departureTime, setDepartureTime] = useState('');
          const saveFavoriteRouteRef = useRef(null); // Ref to hold the save favorite function

          // Autocomplete states
          const [startSuggestions, setStartSuggestions] = useState([]);
          const [endSuggestions, setEndSuggestions] = useState([]);
          const waypointSuggestionsRef = useRef([]); // Array of suggestion arrays
          const [activeInput, setActiveInput] = useState(null); // To track which input has focus for suggestions


          const mapRef = useRef(null);
          const markersRef = useRef([]);
          const routeLayersRef = useRef({});


          // Debounce function for autocomplete
          const debounce = (func, delay) => {
            let timeout;
            return function(...args) {
              const context = this;
              clearTimeout(timeout);
              timeout = setTimeout(() => func.apply(context, args), delay);
            };
          };


          // Autocomplete handler
          const handleAutocomplete = useCallback(debounce(async (query, setSuggestions) => {
            if (query.length < 3) { // Only search if query is at least 3 characters
              setSuggestions([]);
              return;
            }
            if (!GEOAPIFY_API_KEY) {
                console.error('Geoapify API Key is not set for autocomplete.');
                return;
            }
            const encodedQuery = encodeURIComponent(query);
            const autocompleteUrl = `https://api.geoapify.com/v1/geocode/autocomplete?text=${encodedQuery}&limit=5&apiKey=${GEOAPIFY_API_KEY}`;
            try {
              const response = await fetch(autocompleteUrl);
              const data = await response.json();
              if (data.features) {
                setSuggestions(data.features.map(f => ({
                  address: f.properties.formatted,
                  coords: { lat: f.properties.lat, lng: f.properties.lon }
                })));
              }
            } catch (err) {
              console.error('Autocomplete error:', err);
            }
          }, 300), [GEOAPIFY_API_KEY]);


          // Load fuel prices on component mount
          useEffect(() => {
            // Fetch fuel prices based on a default location or current location if available
            if (startCoords) {
                fetchFuelPrices(startCoords.lat, startCoords.lng).then(setFuelPrices);
            } else {
                // Fetch for a default central location (e.g., US) if no startCoords yet
                fetchFuelPrices(39.8283, -98.5795).then(setFuelPrices); 
            }
          }, [startCoords]);


          // Initialize map
          useEffect(() => {
            // Ensure Leaflet library is loaded before initializing the map
            if (typeof window.L === 'undefined') {
              console.warn('Leaflet library not found. Make sure it\'s loaded via CDN in your HTML.');
              return;
            }


            // Initialize the map only once
            if (!mapRef.current) {
              mapRef.current = window.L.map('map').setView([35.79, -78.78], 13); // Default view (e.g., Cary, NC)


              // Add OpenStreetMap tiles
              window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://www.geoapify.com/terms-and-conditions">Geoapify</a>' // Updated attribution
              }).addTo(mapRef.current);


              setMapInitialized(true);


              // Map click handler for setting start/end/waypoints
              mapRef.current.on('click', async (e) => {
                const latlng = e.latlng;
                const readableAddress = await reverseGeocode(latlng.lat, latlng.lng);


                if (!startCoords) {
                  setStartCoords(latlng);
                  setStartLocation(readableAddress);
                } else if (!endCoords) {
                  setEndCoords(latlng);
                  setEndLocation(readableAddress);
                } else {
                  setWaypoints(prev => [...prev, { id: Date.now(), location: readableAddress, coords: latlng }]);
                }
              });
            }
          }, [startCoords, endCoords, waypoints]); // Dependencies to re-run effect if these states change


          // Update markers and routes on map when coordinates or results change
          useEffect(() => {
            if (!mapRef.current || !mapInitialized) return;


            // Clear all existing markers
            markersRef.current.forEach(marker => mapRef.current.removeLayer(marker));
            markersRef.current = [];
            // Clear all existing route layers
            Object.values(routeLayersRef.current).forEach(layer => mapRef.current.removeLayer(layer));
            routeLayersRef.current = {};


            // Add start marker
            if (startCoords) {
              const marker = window.L.marker(startCoords).addTo(mapRef.current)
                .bindPopup('Start Location').openPopup();
              markersRef.current.push(marker);
            }


            // Add end marker
            if (endCoords) {
              const marker = window.L.marker(endCoords).addTo(mapRef.current)
                .bindPopup('End Location').openPopup();
              markersRef.current.push(marker);
            }


            // Add waypoint markers
            waypointCoords.forEach((coords, index) => {
                // Custom icon for waypoints
                const waypointIcon = window.L.divIcon({ 
                    className: 'bg-yellow-500 rounded-full w-6 h-6 flex items-center justify-center text-white font-bold shadow-md', 
                    html: `${index + 1}` 
                });
                const marker = window.L.marker(coords, { icon: waypointIcon }).addTo(mapRef.current)
                    .bindPopup(`Waypoint ${index + 1}`).openPopup();
                markersRef.current.push(marker);
            });


            // Draw routes for each mode
            results.forEach(route => {
                if (route.polyline && route.time !== Infinity) {
                    const decodedPath = toLeafletLatLngs(route.polyline); // Use Geoapify polyline converter
                    let color = 'gray';
                    let weight = 4;
                    let dashArray = null;


                    // Assign colors and styles based on transportation mode
                    switch (route.mode) {
                        case 'driving': color = '#4CAF50'; weight = 5; break; // Green for driving
                        case 'biking': color = '#4CAF50'; weight = 4; dashArray = '5, 5'; break; // Green for biking
                        case 'walking': color = '#4CAF50'; weight = 3; dashArray = '1, 5'; break; // Green for walking
                        case 'transit': color = '#4CAF50'; weight = 4; dashArray = '10, 10'; break; // Green for transit
                    }


                    const polylineLayer = window.L.polyline(decodedPath, { color, weight, opacity: 0.7, dashArray }).addTo(mapRef.current);
                    routeLayersRef.current[route.mode] = polylineLayer;
                }
            });


            // Fit map bounds to all markers and routes
            const allCoords = [
                ...(startCoords ? [[startCoords.lat, startCoords.lng]] : []),
                ...(endCoords ? [[endCoords.lat, endCoords.lng]] : []),
                ...waypointCoords.map(wc => [wc.lat, wc.lng]),
                ...Object.values(routeLayersRef.current).flatMap(layer => layer.getLatLngs())
            ];


            if (allCoords.length > 0) {
                const bounds = window.L.latLngBounds(allCoords);
                mapRef.current.fitBounds(bounds, { padding: [50, 50] });
            } else if (startCoords) {
                // If only start location is set, center map on it
                mapRef.current.setView(startCoords, mapRef.current.getZoom());
            }
          }, [startCoords, endCoords, waypointCoords, results, mapInitialized]);


          // Handles getting user's current geolocation
          const handleGetGeolocation = () => {
            if (navigator.geolocation) {
              navigator.geolocation.getCurrentPosition(
                async (position) => { // Made async to await reverseGeocode
                  const { latitude, longitude } = position.coords;
                  const newCoords = { lat: latitude, lng: longitude };
                  setStartCoords(newCoords);
                  const readableAddress = await reverseGeocode(latitude, longitude);
                  setStartLocation(readableAddress);
                  setError(null);
                  if (mapRef.current) {
                    mapRef.current.setView(newCoords, 15); // Zoom in on current location
                  }
                  
                  // Fetch weather for current location
                  fetchWeatherData(latitude, longitude).then(setWeather);
                  // Fetch fuel prices for current location
                  fetchFuelPrices(latitude, longitude).then(setFuelPrices);
                },
                (geoError) => {
                  console.error('Geolocation error:', geoError);
                  setError(`Error getting location: ${String(geoError.message)}. Please enable location services.`);
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 } // Geolocation options
              );
            } else {
              setError('Geolocation is not supported by your browser.');
            }
          };


          // Function to fetch route for a specific vehicle type using Geoapify Routing API
          const fetchRouteForVehicle = async (points, vehicle, avoidTolls, avoidHighways, departureTime) => {
            if (!GEOAPIFY_API_KEY) {
              console.error('Geoapify API Key is not set or is invalid. Cannot fetch routes.');
              return null;
            }


            const waypointString = points.map(p => `${String(p.lat)},${String(p.lng)}`).join('|');
            let mode = '';
            switch (vehicle) {
                case 'car': mode = 'drive'; break;
                case 'bike': mode = 'bicycle'; break;
                case 'foot': mode = 'walk'; break;
                default: mode = 'drive'; // Default to drive if unknown
            }

            let avoidFeatures = [];
            if (avoidTolls) avoidFeatures.push('toll');
            if (avoidHighways) avoidFeatures.push('motorway');
            const avoidParam = avoidFeatures.length > 0 ? `&avoid_features=${avoidFeatures.join(',')}` : '';

            const departureTimeParam = departureTime ? `&departure_time=${departureTime}` : '';


            // Geoapify Routing API URL
            // instructions=true to get step-by-step instructions
            const apiUrl = `https://api.geoapify.com/v1/routing?waypoints=${waypointString}&mode=${mode}&details=instructions${avoidParam}${departureTimeParam}&apiKey=${GEOAPIFY_API_KEY}`;


            try {
              const response = await fetch(apiUrl);
              if (!response.ok) {
                const errorData = await response.json();
                console.error(`Geoapify Routing API Error for ${vehicle}:`, errorData);
                // Geoapify might return 400 for no route found (e.g., pedestrian over water)
                if (response.status === 400) {
                    return null;
                }
                throw new Error(String(errorData.message) || `Failed to fetch route for ${vehicle}. Please check your API key or try different locations.`);
              }
              const data = await response.json();


              if (data.features && data.features.length > 0) {
                const routeProperties = data.features[0].properties;
                const distanceMeters = routeProperties.distance;
                const durationSeconds = routeProperties.time;
                // Geoapify polyline is an array of [lon, lat] pairs
                const polyline = data.features[0].geometry.coordinates; 
                // FIX: Map directly to instruction string, handling potential nested 'text' property
                const instructions = routeProperties.legs.flatMap(leg => 
                    leg.steps.map(step => typeof step.instruction === 'object' && step.instruction !== null && 'text' in step.instruction 
                                            ? step.instruction.text 
                                            : String(step.instruction))
                );


                return {
                    distanceKm: distanceMeters / 1000,
                    durationMinutes: Math.round(durationSeconds / 60),
                    polyline: polyline, // Keep it as [lon, lat] for now, convert in toLeafletLatLngs
                    instructions: instructions // Now an array of strings
                };
              } else {
                return null; // No route found
              }
            } catch (error) {
              console.error(`Error in fetchRouteForVehicle (${vehicle}):`, error);
              return null; // Return null on error
            }
          };


          // Calculates various metrics (time, cost, CO2, eco points) for different transportation modes.
          const calculateRoutes = (drivingRoute, bikingRoute, walkingRoute, totalDistanceKm, selectedVehicleType, evMode, fuelPrices) => {
            const WALKING_MAX_KM = 15; // Max realistic walking distance for comparison
            const BIKING_MAX_KM = 70; // Max realistic biking distance for comparison


            // Base speeds and costs (can be refined)
            const transitSpeedKmH = 25; // Average transit speed including stops


            const transitBaseCost = 2.75; // Flat fare
            const transitCostPerKm = 0.15;


            const walkingCo2PerKm = 0; // Negligible direct CO2
            const bikingCo2PerKm = 0; // Negligible direct CO2
            const transitCo2PerKm = 0.05; // Average CO2 for public transit (e.g., bus/train)


            // Calculate real fuel costs using fetched prices or defaults
            let fuelCostPerKm = 0.25; // Default cost per km for driving
            let drivingCo2PerKm;
            
            if (fuelPrices) {
                // These MPG/MPGe values are illustrative and can be adjusted for realism
                const mpg = selectedVehicleType === 'electric' ? 120 : (selectedVehicleType === 'hybrid' ? 45 : 25); 
                const fuelPrice = selectedVehicleType === 'electric' ? fuelPrices.electricity : fuelPrices.gasoline;
                
                if (selectedVehicleType === 'electric') {
                    // Cost per km for EV: (price per kWh / MPGe) * conversion factor
                    // Assuming 1 gallon of gasoline equivalent = 33.7 kWh
                    fuelCostPerKm = (fuelPrice / (mpg / 33.7)) * 0.621371; // Convert to cost per km
                } else {
                    fuelCostPerKm = (fuelPrice / mpg) * 0.621371; // Convert to cost per km (miles to km)
                }
            }


            // CO2 emissions per km for driving, adjusted for EV mode and vehicle type
            switch (selectedVehicleType) {
                case 'gasoline':
                    drivingCo2PerKm = evMode ? 0.05 : 0.17; // Lower for EV mode (if hybrid/PHEV)
                    break;
                case 'hybrid':
                    drivingCo2PerKm = evMode ? 0.03 : 0.12; // Even lower for hybrid EV mode
                    break;
                case 'electric':
                    drivingCo2PerKm = 0.02; // Lowest for pure EV (accounts for grid emissions)
                    break;
                default:
                    drivingCo2PerKm = evMode ? 0.05 : 0.17;
            }


            // Eco points for each mode (higher is better)
            const walkingPoints = 100;
            const bikingPoints = 90;
            const transitPoints = 70;
            const drivingPoints = 10;


            const results = [];


            // Driving calculation
            if (drivingRoute) {
                results.push({
                    mode: 'driving',
                    time: drivingRoute.durationMinutes,
                    cost: drivingRoute.distanceKm * fuelCostPerKm,
                    co2: drivingRoute.distanceKm * drivingCo2PerKm,
                    points: drivingPoints + (evMode ? 15 : 0), // Bonus points for EV mode
                    polyline: drivingRoute.polyline,
                    instructions: drivingRoute.instructions,
                    vehicleType: selectedVehicleType,
                    evMode: evMode
                });
            } else {
                // If no driving route found, set time/cost to Infinity
                results.push({
                    mode: 'driving',
                    time: Infinity,
                    cost: Infinity,
                    co2: totalDistanceKm * drivingCo2PerKm, // Still estimate CO2 for comparison
                    points: drivingPoints,
                    vehicleType: selectedVehicleType,
                    evMode: evMode,
                    instructions: []
                });
            }


            // Walking calculation
            if (walkingRoute && totalDistanceKm <= WALKING_MAX_KM) {
                results.push({
                    mode: 'walking',
                    time: walkingRoute.durationMinutes,
                    cost: 0,
                    co2: walkingCo2PerKm,
                    points: walkingPoints,
                    polyline: walkingRoute.polyline,
                    instructions: walkingRoute.instructions
                });
            } else {
                results.push({
                    mode: 'walking',
                    time: Infinity,
                    cost: Infinity,
                    co2: walkingCo2PerKm,
                    points: 0,
                    instructions: []
                });
            }


            // Biking calculation
            if (bikingRoute && totalDistanceKm <= BIKING_MAX_KM) {
                results.push({
                    mode: 'biking',
                    time: bikingRoute.durationMinutes,
                    cost: 0,
                    co2: bikingCo2PerKm,
                    points: bikingPoints,
                    polyline: bikingRoute.polyline,
                    instructions: bikingRoute.instructions
                });
            } else {
                results.push({
                    mode: 'biking',
                    time: Infinity,
                    cost: Infinity,
                    co2: bikingCo2PerKm,
                    points: 0,
                    instructions: []
                });
            }


            // Transit calculation (mocked as Geoapify free tier doesn't support transit for general public)
            let transitTime = Math.round((totalDistanceKm / transitSpeedKmH) * 60);
            // Add some buffer time for transfers/waiting for longer distances
            if (totalDistanceKm > 50) {
                transitTime += 60;
            } else if (totalDistanceKm > 10) {
                transitTime += 30;
            } else {
                transitTime += 15;
            }
            results.push({
              mode: 'transit',
              time: transitTime,
              cost: transitBaseCost + (totalDistanceKm * transitCostPerKm),
              co2: totalDistanceKm * transitCo2PerKm,
              points: transitPoints,
              polyline: null, // No polyline for mocked transit
              instructions: []
            });


            return results;
          };


          // Handlers for input changes
          const handleStartLocationChange = (e) => {
            const value = e.target.value;
            setStartLocation(value);
            setStartCoords(null); // Clear coords to trigger geocoding on submit or autocomplete select
            handleAutocomplete(value, setStartSuggestions);
            setActiveInput('start');
          };


          const handleEndLocationChange = (e) => {
            const value = e.target.value;
            setEndLocation(value);
            setEndCoords(null); // Clear coords to trigger geocoding on submit or autocomplete select
            handleAutocomplete(value, setEndSuggestions);
            setActiveInput('end');
          };


          const handleWaypointLocationChange = (index, e) => {
            const value = e.target.value;
            const newWaypoints = [...waypoints];
            newWaypoints[index].location = value;
            newWaypoints[index].coords = null; // Clear coords
            setWaypoints(newWaypoints);
            // Autocomplete for waypoints (need to manage a ref for suggestions)
            if (!waypointSuggestionsRef.current[index]) {
                waypointSuggestionsRef.current[index] = useState([]);
            }
            handleAutocomplete(value, waypointSuggestionsRef.current[index][1]);
            setActiveInput(`waypoint-${index}`);
          };


          const addWaypoint = () => {
            setWaypoints(prev => [...prev, { id: Date.now(), location: '', coords: null }]);
          };


          const removeWaypoint = (idToRemove) => {
            setWaypoints(prev => prev.filter(wp => wp.id !== idToRemove));
            setWaypointCoords(prev => prev.filter(wc => wc.id !== idToRemove)); // Also remove from geocoded coords
          };


          const handleSelectSuggestion = (type, suggestion) => {
            if (type === 'start') {
              setStartLocation(suggestion.address);
              setStartCoords(suggestion.coords);
              setStartSuggestions([]);
            } else if (type === 'end') {
              setEndLocation(suggestion.address);
              setEndCoords(suggestion.coords);
              setEndSuggestions([]);
            } else if (type.startsWith('waypoint-')) {
              const index = parseInt(type.split('-')[1]);
              setWaypoints(prev => {
                const newWps = [...prev];
                newWps[index].location = suggestion.address;
                newWps[index].coords = suggestion.coords;
                return newWps;
              });
              waypointSuggestionsRef.current[index][1]([]); // Clear specific waypoint suggestions
            }
            setActiveInput(null); // Clear active input
          };


          // Main function to handle route calculation submission
          const handleSubmit = async (e) => {
            e.preventDefault();
            setError(null);
            setResults([]);
            setDistance(null);
            setDrivingDuration(null);
            setIsCalculating(true);


            let currentStartCoords = startCoords;
            let currentEndCoords = endCoords;
            let currentWaypointCoords = [];


            try {
                // Geocode start location if not already set by map click or autocomplete
                if (!currentStartCoords && startLocation) {
                    const geoResult = await geocodeAddress(startLocation);
                    if (geoResult) {
                        currentStartCoords = geoResult;
                        setStartCoords(geoResult);
                        fetchWeatherData(geoResult.lat, geoResult.lng).then(setWeather);
                        fetchFuelPrices(geoResult.lat, geoResult.lng).then(setFuelPrices);
                    } else {
                        throw new Error(`Could not find coordinates for start location: "${String(startLocation)}".`);
                    }
                }


                // Geocode end location if not already set by map click or autocomplete
                if (!currentEndCoords && endLocation) {
                    const geoResult = await geocodeAddress(endLocation);
                    if (geoResult) {
                        currentEndCoords = geoResult;
                        setEndCoords(geoResult);
                    } else {
                        throw new Error(`Could not find coordinates for end location: "${String(endLocation)}".`);
                    }
                }


                // Geocode waypoints
                for (let i = 0; i < waypoints.length; i++) {
                    let waypoint = waypoints[i];
                    if (!waypoint.coords && waypoint.location) {
                        const geoResult = await geocodeAddress(waypoint.location);
                        if (geoResult) {
                            currentWaypointCoords.push(geoResult);
                            setWaypoints(prev => {
                                const newWps = [...prev];
                                newWps[i].coords = geoResult;
                                return newWps;
                            });
                        } else {
                            throw new Error(`Could not find coordinates for waypoint ${String(i + 1)}: "${String(waypoint.location)}".`);
                        }
                    } else if (waypoint.coords) {
                        currentWaypointCoords.push(waypoint.coords);
                    }
                }
                setWaypointCoords(currentWaypointCoords);


                if (!currentStartCoords || !currentEndCoords) {
                    throw new Error('Please provide valid start and end locations, or select them on the map.');
                }


                const allPoints = [currentStartCoords, ...currentWaypointCoords, currentEndCoords];


                // Fetch routes for different modes concurrently, passing avoidances and departure time
                const [drivingRoute, bikingRoute, walkingRoute] = await Promise.all([
                    fetchRouteForVehicle(allPoints, 'car', avoidTolls, avoidHighways, departureTime),
                    fetchRouteForVehicle(allPoints, 'bike', avoidTolls, avoidHighways, departureTime),
                    fetchRouteForVehicle(allPoints, 'foot', avoidTolls, avoidHighways, departureTime)
                ]);


                const totalDistanceKm = drivingRoute ? drivingRoute.distanceKm : 0;
                const totalDrivingDurationMinutes = drivingRoute ? drivingRoute.durationMinutes : 0;


                setDistance(totalDistanceKm);
                setDrivingDuration(totalDrivingDurationMinutes);
                setResults(calculateRoutes(drivingRoute, bikingRoute, walkingRoute, totalDistanceKm, selectedVehicleType, evMode, fuelPrices));


            } catch (err) {
              console.error('Error calculating route:', err);
              setError(String(err.message) || 'Could not calculate route. Please try different locations and ensure API keys are valid.');
            } finally {
              setIsCalculating(false);
            }
          };


          // Loads a favorite route into the input fields.
          const loadFavoriteRoute = (favorite) => {
            setStartLocation(favorite.startLocation);
            setEndLocation(favorite.endLocation);
            setWaypoints(favorite.waypoints || []);
            setStartCoords(null); // Clear coords to force re-geocoding on next submit
            setEndCoords(null);
            setWaypointCoords([]);
            setError(null);
            setResults([]);
          };


          // Calls the save favorite function exposed by the FavoriteRoutes component.
          const handleSaveCurrentRoute = () => {
            if (startLocation && endLocation && saveFavoriteRouteRef.current) {
                saveFavoriteRouteRef.current(startLocation, endLocation, waypoints);
            } else {
                setError('Please enter valid start and end locations to save a route.');
            }
          };


          // State for avoidances
          const [avoidTolls, setAvoidTolls] = useState(false);
          const [avoidHighways, setAvoidHighways] = useState(false);


          // Determine the most eco-friendly option based on CO2 emissions
          const lowestCo2Option = results.length > 0
            ? results.reduce((prev, current) => {
                if (prev.time === Infinity) return current;
                if (current.time === Infinity) return prev;
                return (prev.co2 < current.co2 ? prev : current);
              }).mode
            : null;


          // Helper to get Tailwind CSS classes for card background based on mode
          const getModeColor = (mode) => {
            switch (mode) {
              case 'walking': return 'card-eco-green';
              case 'biking': return 'card-eco-blue';
              case 'transit': return 'card-eco-purple';
              case 'driving': return 'card-eco-red';
              default: return 'bg-[#1a1a1a] border-[#222]'; /* Default dark card */
            }
          };


          // Helper to get an emoji icon for each mode
          const getModeIcon = (mode) => {
            switch (mode) {
              case 'walking': return 'üö∂';
              case 'biking': return 'üö¥';
              case 'transit': return 'üöå';
              case 'driving': return 'üöó';
              default: return '?';
            }
          };


          return (
            <div className="min-h-screen bg-[#0d0d0d] font-sans antialiased text-[#e0e0e0] p-4 sm:p-6 lg:p-8 flex flex-col items-center">
              <div className="max-w-7xl w-full bg-[#1a1a1a] shadow-xl rounded-2xl p-6 sm:p-8 border border-[#222] grid grid-cols-1 lg:grid-cols-4 gap-8">
                {/* Left Sidebar for Inputs and Controls */}
                <div className="lg:col-span-1 bg-[#1a1a1a] p-6 rounded-xl shadow-inner border border-[#222] flex flex-col space-y-6">
                  <h2 className="text-2xl font-bold text-[#e0e0e0] mb-4">Plan Your Eco Journey</h2>
                  <form onSubmit={handleSubmit} className="space-y-6">
                    <div className="relative"> {/* Added relative for autocomplete positioning */}
                      <Label htmlFor="start" className="text-lg font-medium text-[#c0c0e0] mb-2 block">Start Location</Label>
                      <Input
                        id="start"
                        value={startLocation}
                        onChange={handleStartLocationChange}
                        onFocus={() => setActiveInput('start')}
                        onBlur={() => setTimeout(() => setStartSuggestions([]), 100)} // Hide after slight delay
                        placeholder="Enter starting point or click on map"
                      />
                      {activeInput === 'start' && startSuggestions.length > 0 && (
                        <div className="autocomplete-dropdown">
                          {startSuggestions.map((s, i) => (
                            <div key={i} className="autocomplete-item" onMouseDown={() => handleSelectSuggestion('start', s)}>
                              {s.address}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                    <div className="relative"> {/* Added relative for autocomplete positioning */}
                      <Label htmlFor="end" className="text-lg font-medium text-[#c0c0e0] mb-2 block">End Location</Label>
                      <Input
                        id="end"
                        value={endLocation}
                        onChange={handleEndLocationChange}
                        onFocus={() => setActiveInput('end')}
                        onBlur={() => setTimeout(() => setEndSuggestions([]), 100)} // Hide after slight delay
                        placeholder="Enter destination or click on map"
                      />
                      {activeInput === 'end' && endSuggestions.length > 0 && (
                        <div className="autocomplete-dropdown">
                          {endSuggestions.map((s, i) => (
                            <div key={i} className="autocomplete-item" onMouseDown={() => handleSelectSuggestion('end', s)}>
                              {s.address}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                    {/* Waypoints section */}
                    <div className="space-y-4 border-t border-b border-[#222] py-4">
                      <h3 className="text-xl font-semibold text-[#e0e0e0]">Waypoints (Optional)</h3>
                      {waypoints.map((waypoint, index) => (
                        <div key={waypoint.id} className="flex items-center gap-3 relative">
                          <Input
                            value={waypoint.location}
                            onChange={(e) => handleWaypointLocationChange(index, e)}
                            onFocus={() => setActiveInput(`waypoint-${index}`)}
                            onBlur={() => setTimeout(() => waypointSuggestionsRef.current[index] && waypointSuggestionsRef.current[index][1]([]), 100)}
                            placeholder={`Waypoint ${String(index + 1)} or click on map`}
                            className="flex-grow"
                          />
                          <Button
                            type="button"
                            onClick={() => removeWaypoint(waypoint.id)}
                            variant="destructive"
                            size="icon"
                            className="flex-shrink-0"
                          >
                            ‚úñ
                          </Button>
                          {activeInput === `waypoint-${index}` && waypointSuggestionsRef.current[index] && waypointSuggestionsRef.current[index][0].length > 0 && (
                            <div className="autocomplete-dropdown">
                              {waypointSuggestionsRef.current[index][0].map((s, i) => (
                                <div key={i} className="autocomplete-item" onMouseDown={() => handleSelectSuggestion(`waypoint-${index}`, s)}>
                                  {s.address}
                                </div>
                              ))}
                            </div>
                          )}
                        </div>
                      ))}
                      <Button
                        type="button"
                        onClick={addWaypoint}
                        variant="outline"
                        className="w-full py-2 px-4 border-dashed"
                      >
                        + Add Waypoint
                      </Button>
                    </div>
                    {/* Time Optimization */}
                    <TimeOptimization onTimeChange={setDepartureTime} />
                    {/* EV Mode and Vehicle Type */}
                    <div className="space-y-4">
                      <div className="flex items-center space-x-2">
                        <input
                          type="checkbox"
                          id="evMode"
                          checked={evMode}
                          onChange={(e) => setEvMode(e.target.checked)}
                          className="h-5 w-5 text-[#4CAF50] rounded border-[#444] focus:ring-[#4CAF50]" /* Green accent for checkbox */
                        />
                        <Label htmlFor="evMode" className="text-base text-[#c0c0e0]">Enable EV Mode (Lower CO‚ÇÇ for driving)</Label>
                      </div>
                      <div>
                        <Label htmlFor="vehicleType" className="text-base text-[#c0c0e0] mb-2 block">Driving Vehicle Type</Label>
                        <select
                          id="vehicleType"
                          value={selectedVehicleType}
                          onChange={(e) => setSelectedVehicleType(e.target.value)}
                          className="w-full p-3 border border-[#444] rounded-lg focus:ring-2 focus:ring-[#4CAF50] focus:border-transparent transition duration-200 shadow-sm bg-[#222] text-[#e0e0e0]"
                        >
                          <option value="gasoline">Gasoline Car</option>
                          <option value="hybrid">Hybrid Car</option>
                          <option value="electric">Electric Car</option>
                        </select>
                      </div>
                    </div>
                    {/* Avoidances */}
                    <div className="space-y-2">
                        <h3 className="text-xl font-semibold text-[#e0e0e0]">Route Preferences</h3>
                        <div className="flex items-center space-x-2">
                            <input
                                type="checkbox"
                                id="avoidTolls"
                                checked={avoidTolls}
                                onChange={(e) => setAvoidTolls(e.target.checked)}
                                className="h-5 w-5 text-[#4CAF50] rounded border-[#444] focus:ring-[#4CAF50]"
                            />
                            <Label htmlFor="avoidTolls" className="text-base text-[#c0c0e0]">Avoid Tolls</Label>
                        </div>
                        <div className="flex items-center space-x-2">
                            <input
                                type="checkbox"
                                id="avoidHighways"
                                checked={avoidHighways}
                                onChange={(e) => setAvoidHighways(e.target.checked)}
                                className="h-5 w-5 text-[#4CAF50] rounded border-[#444] focus:ring-[#4CAF50]"
                            />
                            <Label htmlFor="avoidHighways" className="text-base text-[#c0c0e0]">Avoid Highways</Label>
                        </div>
                    </div>
                    <div className="flex flex-col gap-4 mt-6">
                      <Button
                        type="submit"
                        disabled={isCalculating || (!startCoords && !startLocation) || (!endCoords && !endLocation)}
                        className={`w-full py-3 px-6 text-lg font-semibold bg-[#4CAF50] text-white hover:bg-[#43A047] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#4CAF50] shadow-lg`}
                      >
                        {isCalculating ? (
                          <span className="flex items-center justify-center">
                            <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            Calculating Routes...
                          </span>
                        ) : (
                          'Compare Routes'
                        )}
                      </Button>
                      <Button
                          type="button"
                          onClick={handleGetGeolocation}
                          disabled={isCalculating}
                          className={`w-full py-3 px-6 text-lg font-semibold bg-[#222] text-[#e0e0e0] hover:bg-[#333] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#444] shadow-lg`}
                      >
                          Use My Current Location üìç
                      </Button>
                      {startLocation && endLocation && (
                        <Button
                            type="button"
                            onClick={handleSaveCurrentRoute}
                            variant="outline"
                            className="w-full"
                        >
                            üíæ Save Route
                        </Button>
                      )}
                    </div>
                  </form>
                  {/* Favorites section */}
                  <FavoriteRoutes onLoadRoute={loadFavoriteRoute} onSaveRoute={saveFavoriteRouteRef} />
                </div>


                {/* Main Content Area (Map and Results) */}
                <div className="lg:col-span-3 flex flex-col space-y-6">
                  {error ? (
                    <div className="p-4 bg-[#F44336] border border-[#D32F2F] text-white rounded-lg text-center font-medium shadow-sm">
                      {error}
                    </div>
                  ) : null}
                  
                  <div id="map" className="flex-grow rounded-xl shadow-md"></div>
                  <p className="text-center text-sm text-[#a0a0c0]">
                    Click on the map to set Start and End locations, or type them in the fields above. Click again to add waypoints.
                  </p>


                  {(distance !== null && drivingDuration !== null) ? (
                    <div className="p-4 bg-[#1a1a1a] border border-[#4CAF50] rounded-lg text-center shadow-sm">
                      <p className="text-xl font-bold text-[#e0e0e0]">
                        Total Driving Distance: <span className="text-[#4CAF50]">{`${String(distance.toFixed(1))} km`}</span>
                      </p>
                      <p className="text-md text-[#c0c0e0] mt-1">
                        Estimated Driving Duration: <span className="text-[#4CAF50]">{`${String(drivingDuration)} minutes`}</span>
                      </p>
                      {fuelPrices ? (
                        <p className="text-sm text-[#a0a0c0] mt-2">
                          {`Current fuel prices: Gasoline $${String(fuelPrices.gasoline)}/gal, Diesel $${String(fuelPrices.diesel)}/gal, Electricity $${String(fuelPrices.electricity)}/kWh (estimated)`}
                        </p>
                      ) : null}
                    </div>
                  ) : null}


                  {results.length > 0 ? <RouteComparisonChart results={results} /> : null}


                  {results.length > 0 ? <CarbonSavingsCalculator results={results} /> : null}


                  {results.length > 0 ? (
                    <MultiModalSuggestions
                      startCoords={startCoords}
                      endCoords={endCoords}
                      results={results}
                    />
                  ) : null}


                  {results.length > 0 ? (
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                      {results.map((result) => (
                        <Card
                          key={result.mode + (result.vehicleType || '')}
                          className={`transition-all duration-300 ease-in-out ${getModeColor(result.mode)} ${lowestCo2Option === result.mode ? 'ring-highlight' : 'border-2'} ${result.time === Infinity ? 'opacity-50 grayscale' : ''} cursor-pointer hover:shadow-lg`}
                          onMouseEnter={() => {
                            if (mapRef.current && routeLayersRef.current[result.mode]) {
                              routeLayersRef.current[result.mode].setStyle({ weight: 8, opacity: 1 }); // Highlight on hover
                            }
                          }}
                          onMouseLeave={() => {
                            if (mapRef.current && routeLayersRef.current[result.mode]) {
                              let weight = 4;
                              switch (result.mode) {
                                case 'driving': weight = 5; break;
                                case 'biking': weight = 4; break;
                                case 'walking': weight = 3; break;
                                case 'transit': weight = 4; break;
                              }
                              routeLayersRef.current[result.mode].setStyle({ weight: weight, opacity: 0.7 }); // Reset style
                            }
                          }}
                        >
                          <CardHeader className="flex flex-row items-center justify-between p-4 pb-2">
                            <CardTitle className="capitalize text-[#e0e0e0]">
                              {result.mode === 'driving' ? `${result.vehicleType || 'Driving'} ${result.mode}` : result.mode}
                            </CardTitle>
                            <span className="text-3xl">{getModeIcon(result.mode)}</span>
                          </CardHeader>
                          <CardContent className="p-4 pt-0">
                            <div className="space-y-2 text-[#c0c0e0]">
                              <p><span>Time:</span> {` ${result.time === Infinity ? 'N/A' : String(result.time) + ' min'}`}</p>
                              <p><span>Cost:</span> {` ${result.cost === Infinity ? 'N/A' : '$' + String(result.cost.toFixed(2))}`}</p>
                              <p><span>CO‚ÇÇ:</span> {` ${String(result.co2.toFixed(2))} kg`}</p>
                              <p><span>Eco Points:</span> {` ${String(result.points)}`}</p>
                            </div>
                            {result.time !== Infinity ? (
                              <RouteDetailsPanel
                                route={result}
                                isExpanded={expandedRoute === result.mode}
                                onToggle={() => setExpandedRoute(expandedRoute === result.mode ? null : result.mode)}
                                weather={weather}
                              />
                            ) : null}
                          </CardContent>
                        </Card>
                      ))}
                    </div>
                  ) : null}


                  {lowestCo2Option ? (
                    <div className="p-5 bg-[#1a1a1a] border border-[#4CAF50] text-[#e0e0e0] rounded-xl text-center shadow-lg">
                      <p className="font-extrabold text-2xl text-[#4CAF50] mb-2">
                        The most eco-friendly option is <span className="capitalize">{lowestCo2Option}</span>! üå±
                      </p>
                      <p className="text-lg text-[#c0c0e0]">
                        Choosing this option results in the lowest CO‚ÇÇ emissions for your journey.
                        <br />
                        Consider walking or biking for shorter distances to maximize your eco-impact!
                      </p>
                    </div>
                  ) : null}


                  {/* Newsletter Signup Section */}
                  <div className="newsletter-section mt-8">
                      <h3 className="text-3xl font-bold mb-4">Stay Green with Our Updates! </h3>
                      <p className="text-lg mb-6">Sign up for our newsletter to get the latest eco-friendly travel tips, new features, and exclusive insights delivered straight to your inbox.</p>
                      <form className="flex flex-col sm:flex-row gap-4 max-w-md mx-auto">
                          <Input
                              type="email"
                              placeholder="Enter your email address"
                              className="flex-grow p-3 rounded-lg text-base"
                          />
                          <Button
                              type="submit"
                              variant="eco"
                              className="py-3 px-6 text-lg font-semibold rounded-lg"
                          >
                              Subscribe
                          </Button>
                      </form>
                      <p className="text-sm text-[#a0a0c0] mt-4">We respect your privacy. Unsubscribe anytime.</p>
                  </div>
                </div>
              </div>
            </div>
          );
        }


        // Render your React App
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            React.createElement(App, null)
        );
    </script>
</body>
</html>

